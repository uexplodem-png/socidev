---
applyTo: '**'
---
# Copilot Instructions for this Project

## Important Guidelines
- **DO NOT create summary files** (no SUMMARY.md, COMPLETION_SUMMARY.md, etc.)
- **DO NOT create documentation files** for tracking progress
- Focus only on actual code changes and fixes
- Keep all explanations in the chat, not in files
- Work directly with the existing codebase without adding new meta-files

## Project Context
- This is a full-stack social media management platform
- Stack: React (frontend/admin-panel), Node.js/Express (backend), MySQL (database)
- Three running apps: Backend (3000), Admin Panel (5173), Frontend (5174)

## When working on tasks:
1. Make direct code changes only
2. Test changes and verify they work
3. Report results in chat (not in files)
4. Suggest next steps conversationally

## GitHub Backup Protocol
**IMPORTANT: Back up every action to GitHub!**
After every significant change or task completion:
1. Stage changes: `git add .`
2. Commit with clear message: `git commit -m "Description of changes"`
3. Push to GitHub: `git push`

GitHub Repository: https://github.com/uexplodem-png/socidev
- Keep commits small and meaningful
- Use present tense in commit messages (e.g., "Add user validation" not "Added")
- Push frequently to maintain backup

## Commands to Remember
- Backend: `/Users/velatertach/Downloads/projects/project\ 5/backend_combined`
- Admin Panel: `/Users/velatertach/Downloads/projects/project\ 5/admin-panel`
- Frontend: `/Users/velatertach/Downloads/projects/project\ 5/frontend`

## Database Optimization Best Practices
**ALWAYS follow these rules when writing database queries:**

### 1. Never Use SELECT * Queries
```javascript
// ❌ BAD - Fetches all fields
const user = await User.findByPk(id);

// ✅ GOOD - Fetches only needed fields
const user = await User.findByPk(id, {
  attributes: ['id', 'firstName', 'lastName', 'email']
});
```

### 2. Use Selective Field Fetching
- Always specify `attributes` array in Sequelize queries
- Only fetch fields that are actually needed
- Reduces memory usage and network transfer
- Example: Profile query needs 10 fields, not all 20+ fields

### 3. Avoid N+1 Query Problems
```javascript
// ❌ BAD - N+1 queries
const orders = await Order.findAll();
for (let order of orders) {
  const user = await User.findByPk(order.userId); // N queries!
}

// ✅ GOOD - Single query with eager loading
const orders = await Order.findAll({
  attributes: ['id', 'status', 'total'],
  include: [{
    model: User,
    attributes: ['id', 'firstName', 'email']
  }]
});
```

### 4. Use raw: true for Aggregations
```javascript
// ✅ For SUM, COUNT, AVG queries
const result = await Order.findOne({
  where: { userId },
  attributes: [[sequelize.fn('SUM', sequelize.col('amount')), 'total']],
  raw: true  // Returns plain object, faster
});
const total = parseFloat(result?.total) || 0;
```

### 5. Index Common Query Patterns
- Always index foreign keys (user_id, order_id, task_id)
- Index status and date fields used in WHERE clauses
- Create composite indexes for common JOIN patterns
- Example: `user_id + status` for filtered listings

### 6. Protect Sensitive Data
- Never expose password fields in queries
- Use field selection to prevent data leaks
- Sanitize user data before returning to client

### 7. Optimize Includes
```javascript
// ✅ Only include what you need
include: [{
  model: User,
  attributes: ['id', 'username'],  // Not all user fields
  required: false  // LEFT JOIN if optional
}]
```

### 8. Use Pagination Properly
```javascript
// ✅ Always paginate large result sets
const { rows, count } = await Order.findAndCountAll({
  where,
  attributes: ['id', 'status', 'createdAt'],  // Select fields
  limit: parseInt(limit),
  offset: (page - 1) * limit,
  order: [['createdAt', 'DESC']]
});
```

### Quick Checklist Before Committing:
- [ ] No SELECT * queries (always use `attributes`)
- [ ] Includes have field selection
- [ ] Aggregations use `raw: true`
- [ ] Foreign keys are indexed
- [ ] Sensitive data is excluded
- [ ] Large result sets are paginated

## Terminal Auto-Approve Settings
"chat.agent.maxRequests": 300,
"chat.tools.terminal.enableAutoApprove": true,
"chat.tools.terminal.autoApprove": {
    "rm": false,
    "rmdir": false,
    "del": false,
    "kill": false,
    "curl": false,
    "wget": false,
    "eval": false,
    "chmod": false,
    "chown": false,
    "/^Remove-Item\\b/i": false
}

## IMPORTANT: Audit & Action Logging (MANDATORY)
- Every admin or user action that changes state MUST record:
  - Audit Logs (system-wide):
    - Fields: id, actor_id, actor_name, actor_email, action, resource, resource_id, target_user_id, target_user_name, description, metadata, ip_address, user_agent, created_at (default list: DESC), updated_at
    - Indexes: (actor_id, created_at), (resource, resource_id), (target_user_id), (created_at)
  - Action Logs (user activity):
    - Fields: id, user_id, type, action, details, ip_address, user_agent, created_at, updated_at
    - Indexes: (user_id, created_at), (type), (created_at)
- Always include IP and User-Agent. Never log secrets.
- Add logAudit/logAction helpers and call them in all critical endpoints (auth events, settings changes, roles/permissions changes, user CRUD, orders, tasks approvals, transactions approve/reject/adjust, refunds).
- Default logs listing order: created_at DESC.

---

# ORDER & TASK MANAGEMENT SYSTEM - COMPLETE IMPLEMENTATION PLAN

## CRITICAL: Implementation Order (Execute Sequentially)

Complete each part fully before moving to the next. Push to GitHub after each part.

---

## PART 1: Database Schema Updates & Indexes

### 1.1 Orders Table Enhancements
**Goal**: Add tracking fields for order management
- Add `unit_price` DECIMAL(10,2) - price per unit for refund calculations
- Add `priority` ENUM('normal', 'urgent', 'critical') DEFAULT 'normal'
- Add `last_status_change` TIMESTAMP - tracks when status changes
- Add `refund_amount` DECIMAL(10,2) NULL - tracks partial/full refunds
- Create composite index on (status, priority, created_at DESC) for sorted listings
- Create composite index on (user_id, platform, service, target_url) for duplicate detection

### 1.2 Order Issues Table (Secure Message System)
**Goal**: Enable secure communication between users and admins about orders
```sql
CREATE TABLE order_issues (
  id INT PRIMARY KEY AUTO_INCREMENT,
  order_id CHAR(36) NOT NULL,
  user_id CHAR(36) NOT NULL,
  admin_id CHAR(36) NULL,
  message TEXT NOT NULL,
  sender_type ENUM('user', 'admin') NOT NULL,
  status ENUM('open', 'in_progress', 'resolved', 'closed') DEFAULT 'open',
  ip_address VARCHAR(45),
  user_agent TEXT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  FOREIGN KEY (order_id) REFERENCES orders(id) ON DELETE CASCADE,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  FOREIGN KEY (admin_id) REFERENCES users(id) ON DELETE SET NULL,
  INDEX idx_order_issues_order (order_id, created_at DESC),
  INDEX idx_order_issues_status (status, created_at DESC)
);
```

### 1.3 Tasks Table Updates
**Goal**: Link tasks to orders and exclude order owners from doing their own tasks
- Add `excluded_user_id` CHAR(36) NULL - user who cannot do this task (order owner)
- Ensure `order_id` exists and has proper foreign key constraint
- Update `remaining_quantity` to track available slots
- Add composite index on (priority DESC, status, created_at ASC) for smart listing
- Add index on excluded_user_id for filtering

### 1.4 Task Executions Table
**Goal**: Track user task attempts with 15-minute reservation system
```sql
CREATE TABLE task_executions (
  id INT PRIMARY KEY AUTO_INCREMENT,
  task_id CHAR(36) NOT NULL,
  user_id CHAR(36) NOT NULL,
  status ENUM('pending', 'submitted', 'approved', 'rejected', 'expired') DEFAULT 'pending',
  proof_url TEXT,
  submission_notes TEXT,
  admin_notes TEXT,
  reserved_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  submitted_at TIMESTAMP NULL,
  expires_at TIMESTAMP NULL COMMENT '15 minutes from reserved_at',
  reviewed_at TIMESTAMP NULL,
  reviewed_by CHAR(36) NULL,
  ip_address VARCHAR(45),
  user_agent TEXT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE CASCADE,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  FOREIGN KEY (reviewed_by) REFERENCES users(id) ON DELETE SET NULL,
  UNIQUE KEY unique_user_task (task_id, user_id),
  INDEX idx_executions_status_expires (status, expires_at),
  INDEX idx_executions_task (task_id, status, created_at DESC),
  INDEX idx_executions_user (user_id, status, created_at DESC)
);
```

**CHECKPOINT**: Run migrations, verify tables, commit to GitHub.

---

## PART 2: Backend - Order Validation & Business Logic

### 2.1 Order Creation Validation
**File**: `backend_combined/src/routes/orders.js`

**Rules**:
1. User cannot create order for same platform+service+target_url if they have pending/processing order
2. User CAN create new order if previous order for same URL is completed/cancelled/refunded
3. Calculate and store unit_price = amount / quantity on creation
4. Log every order creation with full audit trail

**Implementation**:
```javascript
const validateOrderCreation = async (req, res, next) => {
  const { user_id, platform, service, target_url } = req.body;
  
  const existingOrder = await Order.findOne({
    attributes: ['id', 'status'],
    where: {
      user_id,
      platform,
      service,
      target_url,
      status: ['pending', 'processing']
    },
    raw: true
  });

  if (existingOrder) {
    return res.status(400).json({
      error: 'duplicate_order',
      message: 'You already have an active order for this service and URL'
    });
  }
  next();
};
```

### 2.2 Order Progress Calculation
**File**: `backend_combined/src/helpers/orderHelpers.js` (create if not exists)

**Fix progress bar bug**: Progress should be completed_count/quantity * 100, NOT 0/1000%

```javascript
const calculateOrderProgress = (order) => {
  const completed = order.completed_count || 0;
  const total = order.quantity || 0;
  const percentage = total > 0 ? Math.round((completed / total) * 100) : 0;
  
  return {
    completed,
    total,
    percentage: Math.min(percentage, 100),
    remaining: Math.max(total - completed, 0)
  };
};
```

### 2.3 Refund Calculation Logic
**File**: `backend_combined/src/routes/orders.js`

**Refund Rules**:
- If completed_count = 0: Refund full amount
- If completed_count > 0: Refund = unit_price * (quantity - completed_count)
- Update user balance immediately
- Log refund with calculation details
- Set order status to 'refunded'

```javascript
router.post('/orders/:id/refund', authenticateToken, isAdmin, async (req, res) => {
  const transaction = await sequelize.transaction();
  try {
    const order = await Order.findByPk(req.params.id, {
      attributes: ['id', 'user_id', 'amount', 'quantity', 'completed_count', 'status', 'unit_price'],
      transaction
    });

    const unitPrice = parseFloat(order.unit_price || order.amount / order.quantity);
    const completedCount = order.completed_count || 0;
    const refundAmount = completedCount > 0 
      ? unitPrice * (order.quantity - completedCount)
      : parseFloat(order.amount);

    await User.increment('balance', {
      by: refundAmount,
      where: { id: order.user_id },
      transaction
    });

    await order.update({ 
      status: 'refunded',
      refund_amount: refundAmount 
    }, { transaction });

    await logAudit({
      actor_id: req.user.id,
      action: 'order_refunded',
      resource: 'order',
      resource_id: order.id,
      target_user_id: order.user_id,
      description: `Refunded $${refundAmount.toFixed(2)} for order #${order.id}`,
      metadata: { completed: completedCount, total: order.quantity, refund_amount: refundAmount },
      ip_address: req.ip,
      user_agent: req.get('user-agent')
    }, { transaction });

    await transaction.commit();
    res.json({ success: true, refund_amount: refundAmount });
  } catch (error) {
    await transaction.rollback();
    throw error;
  }
});
```

**CHECKPOINT**: Test order validation, refund calculations, commit to GitHub.

---

## PART 3: Backend - Order Issue Reporting (Secure Message System)

### 3.1 Order Issues Routes
**File**: `backend_combined/src/routes/orderIssues.js` (NEW FILE)

**Security Requirements**:
- XSS prevention: Sanitize all user input with `xss` library
- Rate limiting: Max 10 messages per 15 minutes per user
- Access control: Users only see their own order issues, admins see all
- Log all message activities
- Never expose order internal IDs to users (use order reference numbers)

**Key Endpoints**:
1. GET `/orders/:orderId/issues` - List all messages for an order
2. POST `/orders/:orderId/issues` - Send new message
3. PATCH `/issues/:id/status` - Update issue status (admin only)

**Implementation includes**:
- XSS sanitization on all text inputs
- Rate limiter middleware (10 req/15min)
- IP and User-Agent logging
- Message length validation (max 2000 chars)
- Audit trail for every message

**CHECKPOINT**: Test XSS attempts, rate limiting, message threading, commit to GitHub.

---

## PART 4: Backend - Task Auto-Creation from Orders

### 4.1 Task Creation Logic
**File**: `backend_combined/src/routes/orders.js`

**Trigger**: When order status changes from 'pending' to 'processing'

**Task Creation Rules**:
1. Create task with same quantity as order
2. Set `excluded_user_id` = order owner (they cannot do their own order)
3. Set `order_id` to link task to order
4. Copy priority from order
5. Set reward = order amount / quantity
6. Set remaining_quantity = quantity
7. Status = 'active'

**Implementation**:
```javascript
const createTaskFromOrder = async (order, transaction) => {
  const task = await Task.create({
    order_id: order.id,
    excluded_user_id: order.user_id,
    title: `${order.platform} ${order.service} - Order #${order.id.substring(0, 8)}`,
    description: order.notes || `Complete ${order.service} for order`,
    type: order.service.toLowerCase(),
    platform: order.platform,
    target_url: order.target_url,
    quantity: order.quantity,
    remaining_quantity: order.quantity,
    completed_quantity: 0,
    rate: parseFloat(order.unit_price || order.amount / order.quantity),
    priority: order.priority || 'medium',
    status: 'active',
    requirements: order.requirements
  }, { transaction });

  await logAudit({
    actor_id: order.user_id,
    action: 'task_auto_created',
    resource: 'task',
    resource_id: task.id,
    description: `Task auto-created from order #${order.id}`,
    metadata: { order_id: order.id, quantity: order.quantity },
    ip_address: req.ip,
    user_agent: req.get('user-agent'),
    transaction
  });

  return task;
};
```

**Add endpoints**:
- POST `/orders/:id/process` - Move to processing, create task
- POST `/orders/:id/complete` - Mark order complete

**CHECKPOINT**: Test task auto-creation, verify exclusion works, commit to GitHub.

---

## PART 5: Backend - Task Execution & 15-Minute Timer System

### 5.1 Task Execution Routes
**File**: `backend_combined/src/routes/taskExecutions.js` (NEW FILE)

**Task Execution Flow**:
1. User reserves task (15-min timer starts)
2. User submits proof within 15 minutes
3. Admin approves/rejects submission
4. If approved: User gets paid, order progress updates
5. If expired: Slot returns to available pool

**Key Endpoints**:
1. POST `/tasks/:taskId/reserve` - Reserve task slot (15-min timer)
2. PATCH `/executions/:id/submit` - Submit proof before expiry
3. POST `/executions/:id/approve` - Admin approves (admin only)
4. POST `/executions/:id/reject` - Admin rejects (admin only)

**Critical Logic**:
```javascript
// Reserve task
- Check user != excluded_user_id (order owner)
- Check user hasn't already reserved this task (UNIQUE constraint)
- Check remaining_quantity > 0
- Set expires_at = NOW() + 15 minutes
- Decrement task.remaining_quantity
- Create task_execution with status='pending'

// Submit proof
- Verify submission within 15 minutes
- If expired: Update status to 'expired', increment task.remaining_quantity
- If valid: Update status to 'submitted', add proof_url and notes

// Approve execution
- Update execution status to 'approved'
- Increment task.completed_quantity
- Increment order.completed_count
- Add reward to user balance
- If task.completed_quantity >= task.quantity: Set task.status = 'completed'
- If order.completed_count >= order.quantity: Set order.status = 'completed'

// Expire old reservations (cron job - every 5 minutes)
- Find all executions where status='pending', submitted_at IS NULL, expires_at < NOW()
- Set status='expired'
- Increment task.remaining_quantity for each
```

**Cron Job**:
```javascript
const cron = require('node-cron');
cron.schedule('*/5 * * * *', async () => {
  const expired = await TaskExecution.findAll({
    attributes: ['id', 'task_id'],
    where: {
      status: 'pending',
      submitted_at: null,
      expires_at: { [Op.lt]: new Date() }
    }
  });

  for (const execution of expired) {
    await sequelize.transaction(async (t) => {
      await execution.update({ status: 'expired' }, { transaction: t });
      await Task.increment('remaining_quantity', {
        by: 1,
        where: { id: execution.task_id },
        transaction: t
      });
    });
  }
});
```

**CHECKPOINT**: Test reservation expiry, task completion flow, commit to GitHub.

---

## PART 6: Frontend - Admin Panel Order Page Redesign

### 6.1 Orders Page (`admin-panel/src/pages/Orders.jsx`)

**Layout Changes**:
- Sort orders: Priority DESC, then created_at DESC (newest + urgent first)
- Fix progress bar: Show "completed_count / quantity (percentage%)"
- Add action buttons: "Process Order", "Complete Order", "Refund Order"
- Order Details modal: Show all fields, include Order Issues thread
- Edit Order modal: Update all fields correctly

**Progress Bar Component**:
```jsx
const ProgressBar = ({ completed, total }) => {
  const percentage = total > 0 ? Math.round((completed / total) * 100) : 0;
  
  return (
    <div className="w-full bg-gray-200 rounded-full h-4">
      <div 
        className="bg-blue-600 h-4 rounded-full transition-all" 
        style={{ width: `${percentage}%` }}
      />
      <span className="text-sm text-gray-700 mt-1 block">
        {completed}/{total} ({percentage}%)
      </span>
    </div>
  );
};
```

**Order Details Modal**:
- Show Order Issues conversation thread at bottom
- Allow admin to reply to issues inline
- Display refund calculation breakdown if refunded
- Link to task (if exists): "View Associated Task" button

**Action Buttons**:
- "Process Order" → Changes status to 'processing', creates task
- "Complete Order" → Changes status to 'completed'
- "Refund Order" → Shows refund modal with calculation preview

**CHECKPOINT**: Test admin order management, verify UI updates, commit to GitHub.

---

## PART 7: Frontend - Admin Panel Task Management

### 7.1 Tasks Page (`admin-panel/src/pages/Tasks.jsx`)

**Add Features**:
- "Go to Order" button → Navigates to Orders page, filters by order_id
- Show task creator name (from order owner)
- Link to user profile: Click username → Goes to Users page, shows that user

**Task Details**:
- Show remaining_quantity vs quantity
- Display excluded_user (order owner) - "Order Owner: John Doe"
- List all executions (pending, submitted, approved, rejected, expired)

### 7.2 Task Submissions Page (`admin-panel/src/pages/TaskSubmissions.jsx`)

**Redesign for new system**:
- List all executions with status='submitted'
- Show proof_url (screenshot preview)
- Show submission_notes
- Show time remaining before auto-expire (if applicable)
- Actions: "Approve", "Reject" (with reason field)

**Approve Flow**:
- Marks execution as 'approved'
- Credits user balance
- Updates task completed_quantity
- Updates order completed_count
- Shows success toast

**Reject Flow**:
- Marks execution as 'rejected'
- Returns slot to task (increment remaining_quantity)
- Requires rejection reason
- Notifies user

**CHECKPOINT**: Test admin task workflows, commit to GitHub.

---

## PART 8: Frontend - User Panel Updates

### 8.1 User Orders Page (`frontend/src/pages/Orders.jsx`)

**Changes**:
- Remove order ID from display (use order reference only)
- Fix progress bar (same as admin panel)
- Report Issue button → Opens modal with message thread
- Show order status badges with colors

**Report Issue Modal**:
- Display full conversation history (user + admin messages)
- Text input for new message (max 2000 chars)
- Send button (with rate limit warning)
- No order ID visible anywhere

### 8.2 User Tasks Page (`frontend/src/pages/Tasks.jsx`)

**Task Listing**:
- Pagination (20 per page)
- Sort: Priority tasks first (urgent > high > medium > low), then oldest first
- Filter out user's own order tasks (excluded_user_id)
- Show countdown timer for reserved tasks

**Task Card**:
- Platform icon + service type
- Reward amount
- "Reserve Task" button (if available)
- "Submit Proof" button (if reserved by user)
- Status badge (available, reserved by you, in review, etc.)

**Reserve Task Flow**:
1. Click "Reserve Task"
2. Modal: "You have 15 minutes to complete this task"
3. Task moves to "My Active Tasks" section
4. Countdown timer starts
5. Submit proof form appears

**Submit Proof Flow**:
1. Upload screenshot or paste URL
2. Add optional notes
3. Submit before timer expires
4. Shows "Pending Review" status
5. If approved: Balance increases, notification appears
6. If rejected: See rejection reason

**CHECKPOINT**: Test full user flow, verify task filtering, commit to GitHub.

---

## PART 9: Security Hardening & Audit Logging

### 9.1 Input Sanitization
**Install**: `npm install xss express-rate-limit`

**Apply XSS protection to**:
- All order notes
- All issue messages
- All task submission notes
- All admin rejection reasons

**Example**:
```javascript
const xss = require('xss');
const sanitizedMessage = xss(req.body.message.trim());
```

### 9.2 Rate Limiting

**Apply to**:
- Order creation: 10/hour per user
- Issue messages: 10/15 minutes per user
- Task reservations: 20/hour per user

```javascript
const rateLimit = require('express-rate-limit');

const orderLimiter = rateLimit({
  windowMs: 60 * 60 * 1000, // 1 hour
  max: 10,
  message: 'Too many orders created, please try again later'
});

router.post('/orders', authenticateToken, orderLimiter, createOrder);
```

### 9.3 Comprehensive Audit Logging

**Log ALL of these actions**:
- order_created, order_status_changed, order_refunded
- task_created, task_auto_created, task_completed
- task_reserved, task_submitted, task_approved, task_rejected, task_expired
- issue_message_sent, issue_status_changed
- balance_credited (for task approvals)

**Audit Log Format**:
```javascript
await logAudit({
  actor_id: req.user.id,
  action: 'order_refunded',
  resource: 'order',
  resource_id: order.id,
  target_user_id: order.user_id,
  description: `Refunded $${amount} for order #${order.id}`,
  metadata: { completed: 50, total: 100, refund_amount: 50.00 },
  ip_address: req.ip,
  user_agent: req.get('user-agent')
});
```

**CHECKPOINT**: Security audit, test XSS prevention, verify logs, commit to GitHub.

---

## PART 10: Testing & Documentation

### 10.1 End-to-End Test Scenarios

**Test Case 1: Order Creation & Duplicate Prevention**
1. User creates order for Instagram followers
2. Try to create duplicate order → Should fail with error
3. Complete first order
4. Create new order for same URL → Should succeed

**Test Case 2: Progress Bar Accuracy**
1. Create order with quantity=100
2. Verify progress shows "0/100 (0%)"
3. Complete 25 tasks
4. Verify progress shows "25/100 (25%)"

**Test Case 3: Refund Calculation**
1. Order: $100 for 1000 units ($0.10 each)
2. Complete 300 tasks
3. Refund order
4. Verify: User gets $70 refund (700 units * $0.10)

**Test Case 4: Task Exclusion**
1. User A creates order
2. Task auto-created
3. User A tries to reserve task → Should fail
4. User B reserves task → Should succeed

**Test Case 5: 15-Minute Expiry**
1. User reserves task
2. Wait 16 minutes without submitting
3. Cron job runs
4. Task becomes available again
5. Another user can reserve it

**Test Case 6: Order Issues Security**
1. Try to send message with `<script>alert('XSS')</script>`
2. Verify it's sanitized in database
3. Try to send 11 messages in 15 minutes → Should be rate limited
4. Verify IP and user agent are logged

**Test Case 7: Task Approval Flow**
1. User reserves and submits task
2. Admin approves
3. Verify: User balance increases
4. Verify: Task completed_quantity increases
5. Verify: Order completed_count increases
6. When all tasks done: Order status changes to 'completed'

### 10.2 Update Documentation

Create brief updates in:
- README.md: Add "Order & Task Management" section
- Document order workflow diagram
- Document task execution lifecycle
- Document security measures

**CHECKPOINT**: All tests pass, documentation complete, final commit to GitHub.

---

## GitHub Commit Strategy

After each PART completion:
```bash
cd "/Users/velatertach/Downloads/projects/project 5"
git add .
git commit -m "Part X: [Clear description]"
git push origin main
```

**Example Commits**:
- `git commit -m "Part 1: Add order issues and task executions tables with indexes"`
- `git commit -m "Part 2: Implement order validation and refund calculation"`
- `git commit -m "Part 3: Add secure order issue messaging system"`
- `git commit -m "Part 4: Auto-create tasks when orders move to processing"`
- `git commit -m "Part 5: Implement task execution with 15-minute timer"`
- `git commit -m "Part 6: Redesign admin order management page"`
- `git commit -m "Part 7: Update admin task management and submissions"`
- `git commit -m "Part 8: Update user panels with new task system"`
- `git commit -m "Part 9: Add security hardening and comprehensive logging"`
- `git commit -m "Part 10: Complete testing and documentation"`

---

## Critical Implementation Rules

### ALWAYS:
1. ✅ Use transactions for multi-step operations
2. ✅ Specify `attributes` array in all queries (no SELECT *)
3. ✅ Log every significant action with full context
4. ✅ Sanitize all user input (XSS prevention)
5. ✅ Use proper indexes for query optimization
6. ✅ Test each part before moving to next
7. ✅ Commit to GitHub after each part
8. ✅ Include IP and User-Agent in audit logs
9. ✅ Use rate limiting on user-facing endpoints
10. ✅ Validate input lengths and types

### NEVER:
1. ❌ Skip database migrations
2. ❌ Use SELECT * queries
3. ❌ Forget to roll back transactions on error
4. ❌ Expose internal IDs to users unnecessarily
5. ❌ Log sensitive data (passwords, tokens)
6. ❌ Skip audit logging
7. ❌ Allow SQL injection (always use parameterized queries)
8. ❌ Trust user input without sanitization
9. ❌ Make breaking changes without testing
10. ❌ Push untested code to GitHub

---

## Success Criteria Checklist

At the end of implementation, verify:

- [ ] ✅ Users cannot create duplicate active orders
- [ ] ✅ Progress bars show correct percentages (not 0/1000%)
- [ ] ✅ Refunds calculate accurately (partial for completed work)
- [ ] ✅ Order issues have secure messaging (XSS protected)
- [ ] ✅ Tasks auto-create when order status → processing
- [ ] ✅ Order owners cannot do their own tasks
- [ ] ✅ Task reservations expire after 15 minutes
- [ ] ✅ Expired tasks return to available pool
- [ ] ✅ Admin can approve/reject task submissions
- [ ] ✅ User balance updates on task approval
- [ ] ✅ Order completed_count tracks progress accurately
- [ ] ✅ All actions logged with IP and User-Agent
- [ ] ✅ Rate limiting prevents spam/abuse
- [ ] ✅ No XSS vulnerabilities in message system
- [ ] ✅ No SQL injection vulnerabilities
- [ ] ✅ Admin panel shows priority orders first
- [ ] ✅ User panel hides order internal IDs
- [ ] ✅ Task pagination works (oldest first, priority on top)
- [ ] ✅ All database queries optimized (selective fields)
- [ ] ✅ All changes backed up to GitHub
- [ ] ✅ System handles 100+ concurrent users
- [ ] ✅ Cron job expires old reservations every 5 minutes
- [ ] ✅ Documentation complete and accurate

---

## Performance Optimization Notes

### Database:
- All foreign keys indexed ✅
- Composite indexes for common queries ✅
- SELECT only needed fields ✅
- Pagination on all list views ✅
- Use raw: true for aggregations ✅

### Backend:
- Rate limiting on endpoints ✅
- Transaction rollback on errors ✅
- Cron jobs run every 5 minutes ✅
- Audit logs with retention policy ✅

### Frontend:
- Pagination for large lists ✅
- Debounced search inputs ✅
- Loading states for async operations ✅
- Error boundaries for graceful failures ✅

---

## Error Handling Template

Every endpoint must follow this pattern:

```javascript
router.post('/endpoint', authenticateToken, async (req, res) => {
  const transaction = await sequelize.transaction();
  
  try {
    // Input validation
    if (!req.body.required_field) {
      await transaction.rollback();
      return res.status(400).json({ error: 'Missing required field' });
    }

    // Business logic with transaction
    const result = await Model.create({ ... }, { transaction });

    // Audit logging
    await logAudit({
      actor_id: req.user.id,
      action: 'action_name',
      resource: 'resource_type',
      resource_id: result.id,
      description: 'What happened',
      metadata: { ... },
      ip_address: req.ip,
      user_agent: req.get('user-agent'),
      transaction
    });

    await transaction.commit();
    res.json({ success: true, data: result });

  } catch (error) {
    await transaction.rollback();
    console.error('Endpoint error:', error);
    res.status(500).json({ 
      error: 'Operation failed',
      message: process.env.NODE_ENV === 'development' ? error.message : 'Internal error'
    });
  }
});
```

---

## REMEMBER: Execute ONE part at a time. Test thoroughly. Commit to GitHub!

Start with PART 1 now.